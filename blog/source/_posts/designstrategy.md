---
title: 设计模式之策略模式
date: 2017-03-22
categories: 设计模式
tags:
- 设计模式
---
## 策略模式的定义

策略模式属于行为型模式。
![strategydesign](http://ovcjgn2x0.bkt.clouddn.com/strategydesign.png "策略模式")

策略模式是对算法的封装，把一系列的算法分别封装到对应的类中，并且这些类实现相同的接口，相互之间可以替换。在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码。

策略模式的适用场景：如通知服务有三种通知方式：应用服务内部通知、短信和邮件三种方式。根据需要，可能使用三种方式中的任意一种。此种场景可以使用策略模式，客户端根据需求进行相应的选择。

## 策略模式的结构

- 环境类：对策略进行二次封装，目的是避免高层模块对策略的直接调用。
- 抽象策略：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。
- 具体策略：具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。

策略模式的优点：

- 支持“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为，提供了管理相关的算法族的办法。
- 可以避免使用多重条件语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

策略模式的缺点：

- 必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。
- 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

## 策略模式的实践
通知接口，抽象策略类实现：

```java
public interface Notify {
    // 策略方法
    public void notice();
}
```

环境Context的实现：

```java
public class Context {
    //持有一个具体策略的对象
    private Notify notify;
    // 构造函数，传入一个具体策略对象
    public Context(Notify notify){
        this. notify = notify;
    }
    // 策略方法
    public void contextInterface(){
        notify.notice();
    }
}
```

邮件通知策略类的实现：

```java
public class MailNotify implements Notify {
    @Override
    public void notice() {
        //相关的业务
    }
}
```

短信通知策略类的实现：

```java
public class SMSNotify implements Notify {
    @Override
    public void notice() {
        //相关的业务
    }
}
```

客户端进行调用短信通知策略：

```java
public class Client {
    public static void main(String[] args) {
        //选择并创建需要使用的策略对象
        Notify strategy = new SMSNotify();
        //创建环境
        Context context = new Context(strategy);
        //通过环境Context进行调用
        context. contextInterface();
    }
}
```

## 总结
策略模式的重点不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。

适用场景：

- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
- 一个系统需要动态地在几种算法中选择一种。
- 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

### vs工厂模式
工厂模式是创建型模式 ，它关注对象创建，提供创建对象的接口. 让对象的创建与具体的使用客户无关。
策略模式是对象行为型模式 ，它关注行为和算法的封装 。它定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。使得算法可独立于使用它的客户而变化。
### vs模版方法模式
另一种模式也是关注对算法的封装——模版方法模式，对照类图可以看到，策略模式与模版方法模式的区别仅仅是多了一个单独的封装类Context，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码，因此，在很多应用的场景中，在策略模式中一般会看到模版方法模式的影子。

### 参考
1. [23种设计模式（12）：策略模式](http://blog.csdn.net/zhengzhb/article/details/7609670)
2. [设计模式 ( 十八 ) 策略模式Strategy（对象行为型）](http://blog.csdn.net/hguisu/article/details/7558249/)

